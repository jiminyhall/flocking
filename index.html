<!Doctype html>
<html lang="en">
<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link href="css/press-2-0.css" rel="stylesheet">

  <title>Birds of a feather, flock together.</title>
</head>

<body onload="draw()">

  <canvas id="canvas" style="border: 1px solid black;"></canvas>

  <div id='controls'>
    <button class="press press-round press-amber" onclick='start()'>Start</button>
    <button class="press press-round press-amber" onclick='stop()'>Stop</button>
    <button class="press press-round press-amber" onclick='add()'>Add</button>

    <input type="checkbox" id="showBounds" name="showBounds" value="showBounds" checked="true" onclick="showBoundsClicked(this)">
    <label for="showBounds">Bounds</label>
    <span id="boundsVal"></span>
    <button class="press press-round press-amber" onclick='boundsChange(0.1)'>/\</button>
    <button class="press press-round press-amber" onclick='boundsChange(-0.1)'>\/</button>

    <span>Alignment Weight: <span id="alignmentVal"></span></span>
    <button class="press press-round press-amber" onclick='alignmentChange(0.1)'>/\</button>
    <button class="press press-round press-amber" onclick='alignmentChange(-0.1)'>\/</button>

    <span>Cohesion Weight: <span id="cohesionVal"></span></span>
    <button class="press press-round press-amber" onclick='cohesionChange(0.1)'>/\</button>
    <button class="press press-round press-amber" onclick='cohesionChange(-0.1)'>\/</button>


  </div>

  <div id='info' style='display:none;'>
    x:
    <br>y:
    <br>r:
  </div>

  <script>

  /* BASIC FLOCKING BEHAVIOUR use this tutorial
   * https://gamedevelopment.tutsplus.com/tutorials/3-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation--gamedev-3444
   *
   *  To add:
   *    - round bounding boxes (slightly cleverer maths required)
   *    - change behaviour based on neighbour count
   *    - add different kinds of birds
   *    - more control/information
   *    - uniform grid collision detection
   */

  var agents;     //list of all agents on the canvas
  var myInterval; //window timer
  var showBounds = true;
  var boundsWeight = 2.0;
  var alignmentWeight = 0.0;
  var cohesionWeight = 0.5;

  function boundsChange(val) {
    boundsWeight += val;
    if(boundsWeight < 0.1) boundsWeight = 0.1;
    document.getElementById('boundsVal').innerHTML = boundsWeight.toFixed(2);
    clear();
    for(i=0; i<agents.length; i++) { agents[i].draw(); };
  }

  function alignmentChange(val) {
    alignmentWeight += val;
    if(alignmentWeight < 0.0) alignmentWeight = 0.0;
    if(alignmentWeight > 1.0) alignmentWeight = 1.0;
    document.getElementById('alignmentVal').innerHTML = alignmentWeight.toFixed(2);
  }

  function cohesionChange(val) {
    cohesionWeight += val;
    if(cohesionWeight < 0.0) cohesionWeight = 0.0;
    if(cohesionWeight > 1.0) cohesionWeight = 1.0;
    document.getElementById('cohesionVal').innerHTML = cohesionWeight.toFixed(2);
  }

  function showBoundsClicked(evt) {
    console.log("CB clicked");
    showBounds = evt.checked;
    clear();
    for(i=0; i<agents.length; i++) { agents[i].draw(); };
  }



  function add() {
    var ctx = document.getElementById('canvas').getContext('2d');
    agents.push(new Agent(Math.random()*ctx.canvas.width,     //x
                          Math.random()*ctx.canvas.height,    //y
                          Math.random()*360,                  //rotation
                          (Math.random()*2)+1,                //speed - was using a randomised value but removing for alignment // (Math.random()*2)+1,
                          "bird.png"));                       //sprite
  }

  function draw() {
    var ctx = document.getElementById('canvas').getContext('2d');
    ctx.canvas.width = window.innerWidth-20;
    ctx.canvas.height = window.innerHeight*0.9;
    document.getElementById('boundsVal').innerHTML = boundsWeight.toFixed(2);
    document.getElementById('alignmentVal').innerHTML = alignmentWeight.toFixed(2);
    document.getElementById('cohesionVal').innerHTML = cohesionWeight.toFixed(2);
    agents = [new Agent(ctx.canvas.width/2,ctx.canvas.height/2,0,1,"bird.png")];
    ctx.canvas.onmousedown = onmousedown;
  }

  function onmousedown(e) {

    /* NEED TO FIGURE OUT THE EVENT X/Ys AND WHAT THEY RETURN FROM THE MOUSE EVENT
     *
     * READ THIS: http://www.informit.com/articles/article.aspx?p=1903884&seqNum=6
     *
    */

    var ctx = document.getElementById('canvas').getContext('2d');
    console.log("Mouse clicked: " + (e.clientX-ctx.canvas.offsetTop) + "," + (e.clientY-ctx.canvas.offsetLeft));
    //check if any of the existing agents have been clicked (return first one)
    for(var i=0; i<agents.length; i++)
    {
      //console.log(agents[i].image.height + " " + agents[i].y);
      var ag_x = agents[i].x;
      var ag_y = agents[i].y;
      var ag_w = agents[i].image.width;
      var ag_h = agents[i].image.height;
      console.log( ag_x + "," + ag_y + " " + ag_w + "," + ag_h);

      if(e.clientX >= ag_x && e.clientX <= (ag_x+ag_w) && e.clientY >=ag_y && e.clientY <= (ag_y+ag_h))
        console.log("X+Y hit");


    }
  }

  function stop() {
    clearInterval(myInterval);
  }

  var speed;

  function start() {
    myInterval = setInterval(function() { update(); }, 20);
  }

  function update() {

      clear();
      // go through each agent and move/turn, then draw (avoids iterating list twice)

      for(i=0; i<agents.length; i++) {

        // return an array of agents which are within within radius
        var neighbourhood = agents.filter(function (el) { return el.testCircle(agents[i].x, agents[i].y) && el!=agents[i]; });

        if(neighbourhood.length>0) {
          /* If one or more agents in within its radius (or neighbourhood) then there are three flocking behviours to apply
           * 1. alignment - the agents will change path to an average
           * 2. cohesion - the agents will try and move to be closer together
           * 3. seperation - the agents will try and keep a certain distance away from each other
           */

          /* 1. Alignment
           * This section adds in the weight of the rotation (between 0 and 1), finds the difference between the
           * target and current then adds a proportion based on the alignmentWeight */
          var averageRotation = neighbourhood.reduce(function (total, el) { return total+el.rotation; },0) / neighbourhood.length;
          var differenceRotation = averageRotation - agents[i].rotation;
          var weightedRotation = differenceRotation * alignmentWeight;
          agents[i].rotation+=weightedRotation;

          /* 2. Cohesion
           *     - find the average new X and Y from the neighbourhood
           *     - find the angle to the new point (rotation)
           *     - apply weighting and add to existing rotation
           */
          var averageLocation_X = neighbourhood.reduce(function (total, el) { return total+el.x; },0) / neighbourhood.length;
          var averageLocation_Y = neighbourhood.reduce(function (total, el) { return total+el.y; },0) / neighbourhood.length;
          var tx = averageLocation_X - agents[i].x;
          var ty = averageLocation_Y - agents[i].y;
          // for some reason the atan function returns the -90 rotated, so use the two known sides, work out the
          // resulting angle and alter so it is correct for this scenario.
          var t_rot = Math.atan2(ty,tx) * (180/Math.PI) + 90;
          if(t_rot<0) t_rot=360+t_rot;
          var diff_rot = t_rot-agents[i].rotation;
          weightedRotation = diff_rot * cohesionWeight;
          agents[i].rotation+=weightedRotation;
          console.log("C_r: " + agents[i].rotation.toFixed(0) + " with nbrs: " + neighbourhood.length + " t_x/y: " + tx.toFixed(0) +","+ty.toFixed(0) +  " @ " + t_rot.toFixed(0) + " diff: " + diff_rot);

        } else {
          // if no neighbours then randomise rotation
          var rand = Math.random();
          if(rand<0.1)
            agents[i].rotate((Math.random()*30)-15);

        }

        agents[i].forward();

        //console.log(newArry.length);
        // if(newArry.length>1) { console.log("HIT"); };
        agents[i].neighbourCount = neighbourhood.length;
        agents[i].draw();
      }
  }


  function Agent(x, y, rotation, speed, src) {

    this.neighbourCount = 0;
    this.collisionRadius = 100;
    this.rotation = rotation;
    this.speed = speed;
    this.x = x;
    this.y = y;
    this.image = new Image();

    this.image.onload = function() {
        document.getElementById('canvas').getContext('2d').drawImage(this,x-this.width/2,y-this.height/2);
        document.getElementById('info').innerHTML = "x: " + x + "<br>y: " + y + "<br>r: " + rotation;
    };

    this.image.src = src;

    this.testCircle = function(dx,dy) {
        if( dx>this.x-((this.collisionRadius*boundsWeight)/2) &&
            dx<this.x+((this.collisionRadius*boundsWeight)/2) &&
            dy>this.y-((this.collisionRadius*boundsWeight)/2) &&
            dy<this.y+((this.collisionRadius*boundsWeight)/2))
        {
            return true;
        } else {
          return false;
        }
    }




    this.forward = function() {

      this.x += this.speed*Math.sin(this.rotation*Math.PI/180);
      this.y -= this.speed*Math.cos(this.rotation*Math.PI/180);



      // if moving takes over the edge of canvas then reposition
      if(this.y<0) {
          this.y = document.getElementById('canvas').height - this.y;
          //this.x = document.getElementById('canvas').width - this.x;
      } else if(this.y>document.getElementById('canvas').height) {
          this.y = this.y-document.getElementById('canvas').height;
          //this.x = document.getElementById('canvas').width - this.x;
      }

      if(this.x<0) {
          this.x = document.getElementById('canvas').width - this.x;
          //this.y = document.getElementById('canvas').height - this.y;
      } else if(this.x>document.getElementById('canvas').width) {
          this.x = this.x-document.getElementById('canvas').width;
          //this.y = document.getElementById('canvas').height - this.y;
      }

    };

    this.rotate = function(degrees) {
        this.rotation += degrees;
        if(this.rotation>359) this.rotation=this.rotation-360;
        if(this.rotation<0) this.rotation=this.rotation+360;
    }

    this.draw = function() {
      var ctx = document.getElementById('canvas').getContext('2d');
      ctx.save();
      ctx.translate(this.x,this.y);

      if(showBounds) {
        // Draw bounding
        ctx.beginPath();
        // ctx.arc(0,0,100,0,2*Math.PI);
        ctx.rect((this.collisionRadius*boundsWeight)/-2,(this.collisionRadius*boundsWeight)/-2,this.collisionRadius*boundsWeight,this.collisionRadius*boundsWeight);
        if(this.neighbourCount>0) {
          // if a neighbour is present then colour in red
          ctx.strokeStyle='red';
        } else {
          // else colour it in black
          ctx.strokeStyle='black';
        }
        ctx.stroke();
      }

      // rotate and draw image
      ctx.rotate(this.rotation*Math.PI/180);
      ctx.drawImage(this.image,this.image.width/-2,this.image.height/-2);
      ctx.restore();
      document.getElementById('info').innerHTML = "x: " + this.x + "<br>y: " +this.y+ "<br>r: " + this.rotation;
    };

  }


  function clear() {
    // clear the canvas
    var w = document.getElementById('canvas').width;
    var h = document.getElementById('canvas').height;
    // console.log("W/h:" + w + "/" + h);
    document.getElementById('canvas').getContext('2d').clearRect(0,0,w,h);
  }



  </script>


</body>
</html>
