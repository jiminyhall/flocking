<!Doctype html>
<html lang="en">
<head>
  <!-- Required meta tags -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <link href="css/press-2-0.css" rel="stylesheet">

  <title>Birds of a feather, flock together.</title>
</head>

<body onload="draw()">

  <canvas id="canvas" style="border: 1px solid black;"></canvas>

  <div id='controls'>
    <button class="press press-round press-amber" onclick='start()'>Start</button>
    <button class="press press-round press-amber" onclick='stop()'>Stop</button>
    <button class="press press-round press-amber" onclick='add()'>Add</button>

    <input type="checkbox" id="showBounds" name="showBounds" value="showBounds" checked="true" onclick="showBoundsClicked(this)">
    <label for="showBounds">Bounds</label>
    <span id="boundsVal"></span>
    <button class="press press-round press-amber" onclick='boundsChange(0.1)'>/\</button>
    <button class="press press-round press-amber" onclick='boundsChange(-0.1)'>\/</button>

    <span>Alignment Weight: <span id="alignmentVal"></span></span>
    <button class="press press-round press-amber" onclick='alignmentChange(0.1)'>/\</button>
    <button class="press press-round press-amber" onclick='alignmentChange(-0.1)'>\/</button>

  </div>

  <div id='info' style='display:none;'>x:
    <br>y:
    <br>r:
  </div>

  <script>

  /* BASIC FLOCKING BEHAVIOUR use this tutorial
   * https://gamedevelopment.tutsplus.com/tutorials/3-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation--gamedev-3444
   *
   *  To add:
   *    - round bounding boxes (slightly cleverer maths required)
   *    - change behaviour based on neighbour count
   *    - add different kinds of birds
   *    - more control/information
   */

  var agents;     //list of all agents on the canvas
  var myInterval; //window timer
  var showBounds = true;
  var boundsWeight = 1.0;
  var alignmentWeight = 1.0;

  function boundsChange(val) {
    boundsWeight += val;
    if(boundsWeight < 0.1) boundsWeight = 0.1;
    document.getElementById('boundsVal').innerHTML = boundsWeight.toFixed(2);
    clear();
    for(i=0; i<agents.length; i++) { agents[i].draw(); };
  }

  function alignmentChange(val) {
    alignmentWeight += val;
    if(alignmentWeight < 0.0) alignmentWeight = 0.0;
    if(alignmentWeight > 1.0) alignmentWeight = 1.0;
    document.getElementById('alignmentVal').innerHTML = alignmentWeight.toFixed(2);
  }


  function showBoundsClicked(evt) {
    console.log("CB clicked");
    showBounds = evt.checked;
    clear();
    for(i=0; i<agents.length; i++) { agents[i].draw(); };

  }

  function add() {
    var ctx = document.getElementById('canvas').getContext('2d');
    agents.push(new Agent(Math.random()*ctx.canvas.width,     //x
                          Math.random()*ctx.canvas.height,    //y
                          Math.random()*360,                  //rotation
                          (Math.random()*2)+1,                //speed - was using a randomised value but removing for alignment // (Math.random()*2)+1,
                          "bird.png"));                       //sprite
  }

  function draw() {

    var ctx = document.getElementById('canvas').getContext('2d');
    ctx.canvas.width = window.innerWidth-20;
    ctx.canvas.height = window.innerHeight*0.9;
    document.getElementById('boundsVal').innerHTML = boundsWeight.toFixed(2);
    document.getElementById('alignmentVal').innerHTML = alignmentWeight.toFixed(2);
    agents = [new Agent(ctx.canvas.width/2,ctx.canvas.height/2,0,1,"bird.png")];

  }

  function stop() {
    clearInterval(myInterval);
  }

  var speed;

  function start() {
    myInterval = setInterval(function() { update(); }, 20);
  }

  function update() {

      clear();
      // go through each agent and move/turn, then draw (avoids iterating list twice)

      for(i=0; i<agents.length; i++) {
        var rand = Math.random();
        if(rand<0.9) {
          agents[i].forward();
        } else {
          agents[i].rotate((Math.random()*30)-15);
        }
        // return an array of agents which are within within radius
        var newArry = agents.filter(function (el) { return el.testCircle(agents[i].x, agents[i].y) && el!=agents[i]; });

        if(newArry.length>0) {
          var averageRotation = newArry.reduce(function (total, el) { console.log("el.rat"); return total+el.rotation; },0);
          averageRotation = averageRotation/newArry.length;
          console.log(averageRotation);
          var differenceRotation = averageRotation - agents[i].rotation;
          var weightedRotation = differenceRotation * alignmentWeight;
          agents[i].rotation+=weightedRotation;
        }

        //console.log(newArry.length);
        // if(newArry.length>1) { console.log("HIT"); };
        agents[i].neighbourCount = newArry.length;
        agents[i].draw();
      }
  }


  function Agent(x, y, rotation, speed, src) {

    this.neighbourCount = 0;
    this.collisionRadius = 100;
    this.rotation = rotation;
    this.speed = speed;
    this.x = x;
    this.y = y;
    this.image = new Image();

    this.image.onload = function() {
        document.getElementById('canvas').getContext('2d').drawImage(this,x-this.width/2,y-this.height/2);
        document.getElementById('info').innerHTML = "x: " + x + "<br>y: " + y + "<br>r: " + rotation;
    };

    this.image.src = src;

    this.testCircle = function(dx,dy) {
        if( dx>this.x-((this.collisionRadius*boundsWeight)/2) &&
            dx<this.x+((this.collisionRadius*boundsWeight)/2) &&
            dy>this.y-((this.collisionRadius*boundsWeight)/2) &&
            dy<this.y+((this.collisionRadius*boundsWeight)/2))
        {
            return true;
        } else {
          return false;
        }
    }




    this.forward = function() {

      this.x += this.speed*Math.sin(this.rotation*Math.PI/180);
      this.y -= this.speed*Math.cos(this.rotation*Math.PI/180);



      // if moving takes over the edge of canvas then reposition
      if(this.y<0) {
          this.y = document.getElementById('canvas').height - this.y;
          //this.x = document.getElementById('canvas').width - this.x;
      } else if(this.y>document.getElementById('canvas').height) {
          this.y = this.y-document.getElementById('canvas').height;
          //this.x = document.getElementById('canvas').width - this.x;
      }

      if(this.x<0) {
          this.x = document.getElementById('canvas').width - this.x;
          //this.y = document.getElementById('canvas').height - this.y;
      } else if(this.x>document.getElementById('canvas').width) {
          this.x = this.x-document.getElementById('canvas').width;
          //this.y = document.getElementById('canvas').height - this.y;
      }

    };

    this.rotate = function(degrees) {
        this.rotation += degrees;
        if(this.rotation>359) this.rotation=this.rotation-360;
        if(this.rotation<0) this.rotation=this.rotation+360;
    }

    this.draw = function() {
      var ctx = document.getElementById('canvas').getContext('2d');
      ctx.save();
      ctx.translate(this.x,this.y);

      if(showBounds) {
        // Draw bounding
        ctx.beginPath();
        // ctx.arc(0,0,100,0,2*Math.PI);
        ctx.rect((this.collisionRadius*boundsWeight)/-2,(this.collisionRadius*boundsWeight)/-2,this.collisionRadius*boundsWeight,this.collisionRadius*boundsWeight);
        if(this.neighbourCount>1) {
          ctx.strokeStyle='red';
        } else {
          ctx.strokeStyle='black';
        }
        ctx.stroke();
      }

      // rotate and draw image
      ctx.rotate(this.rotation*Math.PI/180);
      ctx.drawImage(this.image,this.image.width/-2,this.image.height/-2);
      ctx.restore();
      document.getElementById('info').innerHTML = "x: " + this.x + "<br>y: " +this.y+ "<br>r: " + this.rotation;
    };

  }


  function clear() {
    // clear the canvas
    var w = document.getElementById('canvas').width;
    var h = document.getElementById('canvas').height;
    // console.log("W/h:" + w + "/" + h);
    document.getElementById('canvas').getContext('2d').clearRect(0,0,w,h);
  }



  </script>


</body>
</html>
