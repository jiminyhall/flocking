<!Doctype html>
<html>
<head></head>
<body onload="draw()" style="text-align:center;">

  <canvas id="canvas" width="300" height="500" style="border: 1px solid black"></canvas>
  <br>
  <div id='controls'>
  <button onclick='start()'>Start</button>
  <button onclick='stop()'>Stop</button>
  <button onclick='add()'>Add</button>
  </div>
  <br>
  <div id='info' style='display:none;'>x:
    <br>y:
    <br>r:
  </div>
  <script>

  /* BASIC FLOCKING BEHAVIOUR use this tutorial
   * https://gamedevelopment.tutsplus.com/tutorials/3-simple-rules-of-flocking-behaviors-alignment-cohesion-and-separation--gamedev-3444
   *
   *  To add:
   *    - round bounding boxes (slightly cleverer maths required)
   *    - change behaviour based on neighbour count
   *    - add different kinds of birds
   *    - more control/information
   */

  var agents;     //list of all agents on the canvas
  var myInterval; //window timer

  function add() {
    agents.push(new Agent(150,75,0,(Math.random()*2)+1,"bird.png"));
  }

  function draw() {

    var ctx = document.getElementById('canvas').getContext('2d');
    ctx.canvas.width = window.innerWidth-20;
    ctx.canvas.height = window.innerHeight*0.9;
    agents = [new Agent(150,75,0,1,"bird.png")];

  }

  function stop() {
    clearInterval(myInterval);
  }

  function start() {
    myInterval = setInterval(function() { update(); }, 20);
  }

  function update() {

      clear();
      // go through each agent and move/turn, then draw (avoids iterating list twice)

      for(i=0; i<agents.length; i++) {
        var rand = Math.random();
        if(rand<0.9) {
          agents[i].forward();
        } else {
          agents[i].rotate((Math.random()*30)-15);
        }
        // check if any are within radius
        var newArry = agents.filter(function (el) {
          return el.testCircle(agents[i].x, agents[i].y);
        })
        //console.log(newArry.length);
        // if(newArry.length>1) { console.log("HIT"); };
        agents[i].neighbourCount = newArry.length;
        agents[i].draw();
      }
  }


  function Agent(x, y, rotation, speed, src) {

    this.neighbourCount = 0;
    this.collisionRadius = 100;
    this.rotation = rotation;
    this.speed = speed;
    this.x = x;
    this.y = y;
    this.image = new Image();

    this.image.onload = function() {
        document.getElementById('canvas').getContext('2d').drawImage(this,x-this.width/2,y-this.height/2);
        document.getElementById('info').innerHTML = "x: " + x + "<br>y: " + y + "<br>r: " + rotation;
    };

    this.image.src = src;

    this.testCircle = function(dx,dy) {
        if( dx>this.x-(this.collisionRadius/2) &&
            dx<this.x+(this.collisionRadius/2) &&
            dy>this.y-(this.collisionRadius/2) &&
            dy<this.y+(this.collisionRadius/2))
        {
            return true;
        } else {
          return false;
        }
    }




    this.forward = function() {

      this.x += this.speed*Math.sin(this.rotation*Math.PI/180);
      this.y -= this.speed*Math.cos(this.rotation*Math.PI/180);



      // if moving takes over the edge of canvas then reposition
      if(this.y<0) {
          this.y = document.getElementById('canvas').height - this.y;
          //this.x = document.getElementById('canvas').width - this.x;
      } else if(this.y>document.getElementById('canvas').height) {
          this.y = this.y-document.getElementById('canvas').height;
          //this.x = document.getElementById('canvas').width - this.x;
      }

      if(this.x<0) {
          this.x = document.getElementById('canvas').width - this.x;
          //this.y = document.getElementById('canvas').height - this.y;
      } else if(this.x>document.getElementById('canvas').width) {
          this.x = this.x-document.getElementById('canvas').width;
          //this.y = document.getElementById('canvas').height - this.y;
      }

    };

    this.rotate = function(degrees) {
        this.rotation += degrees;
        if(this.rotation>359) this.rotation=this.rotation-360;
        if(this.rotation<0) this.rotation=this.rotation+360;
    }

    this.draw = function() {
      var ctx = document.getElementById('canvas').getContext('2d');
      ctx.save();
      ctx.translate(this.x,this.y);

      // Draw bounding
      ctx.beginPath();
      // ctx.arc(0,0,100,0,2*Math.PI);
      ctx.rect(100/-2,100/-2,100,100);
      if(this.neighbourCount>1) {
        ctx.strokeStyle='red';
      } else {
        ctx.strokeStyle='black';
      }
      ctx.stroke();

      // rotate and draw image
      ctx.rotate(this.rotation*Math.PI/180);
      ctx.drawImage(this.image,this.image.width/-2,this.image.height/-2);
      ctx.restore();
      document.getElementById('info').innerHTML = "x: " + this.x + "<br>y: " +this.y+ "<br>r: " + this.rotation;
    };

  }


  function clear() {
    // clear the canvas
    var w = document.getElementById('canvas').width;
    var h = document.getElementById('canvas').height;
    // console.log("W/h:" + w + "/" + h);
    document.getElementById('canvas').getContext('2d').clearRect(0,0,w,h);
  }



  </script>



</body>
</html>
